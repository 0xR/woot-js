{"version":3,"sources":["woot.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,IAAI,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;;AAEzB,IAAI,IAAI,GAAG,OAAO,CAAC,aAAa,CAAC,CAAC;AAClC,IAAI,OAAO,GAAG,OAAO,CAAC,gBAAgB,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;AAwBxC,IAAI,cAAc,GAAG,CAAC,CAAC,KAAK,CAAC,UAAS,OAAO,EAAE,QAAQ,EAAE;AACvD,SAAO;AACL,YAAQ,EAAE,QAAQ;AAClB,SAAK,EAAE,CAAC;AACR,WAAO,EAAE,OAAO;AAChB,kBAAc,EAAE,EAAE;GACnB,CAAC;CACH,CAAC,CAAC;;AAEH,IAAI,mBAAmB,GAAG,cAAc,CAAC,OAAO,CAAC,gBAAgB,EAAE,CAAC,CAAC;;;;;;;;;;;;;;AAcrE,IAAI,aAAa,GAAG,SAAhB,aAAa,CAAY,MAAM,EAAE,SAAS,EAAE;AAC9C,MAAI,UAAU,GAAG,CAAC,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,UAAU,CAAC,CAAC;AACxD,MAAI,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC;;AAE3D,SAAO,aAAa,CAAC,MAAM,CAAC,OAAO,EACjC,gBAAgB,CAAC,MAAM,CAAC,UAAU,EAAE,MAAM,CAAC,CAC5C,CAAC;CACH,CAAC;;AAEF,IAAI,gBAAgB,GAAG,CAAC,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;AAC7C,IAAI,aAAa,GAAG,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BvC,MAAM,CAAC,OAAO,GAAG;AACf,gBAAc,EAAE,cAAc;AAC9B,qBAAmB,EAAE,mBAAmB;AACxC,eAAa,EAAE,aAAa;CAC7B,CAAA","file":"woot.js","sourcesContent":["// module Data.Woot\n//     ( WootClient\n//     , wootClientId\n//     , wootClientClock\n//     , wootClientString\n//     , wootClientOperationQueue\n//\n//     -- Construction\n//     , makeWootClient\n//     , makeWootClientEmpty\n//\n//     -- Operation handling\n//     , sendOperation\n//     , sendOperations\n//     , sendLocalDelete\n//     , sendLocalInsert\n//\n//     -- Useful data types from other modules\n//     , WString\n//     , WChar(..)\n//     , WCharId(..)\n//     , Operation(..)\n//     , ClientId\n//     ) where\n\nvar R = require('ramda');\n\nvar Core = require('./woot/core');\nvar WString = require('./woot/wstring');\n//\n// import Data.Woot.Core\n// import Data.Woot.Operation\n// import Data.Woot.WChar\n// import Data.Woot.WString\n//\n//\n// data WootClient = WootClient\n//     { wootClientId             :: Int\n//     , wootClientClock          :: Int\n//     , wootClientString         :: WString\n//     , wootClientOperationQueue :: [Operation]\n//     } deriving (Eq, Show)\n//\n//\n// incClock :: WootClient -> WootClient\n// incClock client = client {wootClientClock = succ $ wootClientClock client}\n//\n//\n// -- TODO: should this check is the client id already exists in the provided string\n// -- and then start the client clock at the correct value?\n// makeWootClient :: WString -> ClientId -> WootClient\n// makeWootClient ws cid = WootClient cid 0 ws []\nvar makeWootClient = R.curry(function(wString, clientId) {\n  return {\n    clientId: clientId,\n    clock: 0,\n    wString: wString,\n    operationQueue: []\n  };\n});\n\nvar makeWootClientEmpty = makeWootClient(WString.makeEmptyWString());\n\n//\n// makeWootClientEmpty :: ClientId -> WootClient\n// makeWootClientEmpty = makeWootClient emptyWString\n//\n//\n// -- sends an operation to a woot client, returning a new woot client\n// -- the operation will either be integrated into the woot client's string\n// -- or it will be added to the client's interal operation queue to be tried again\n// sendOperation :: WootClient -> Operation -> WootClient\n// sendOperation (WootClient cid clock ws ops) op = WootClient cid clock ws' ops'\n//     where\n//       (ops', ws') = integrateAll (op:ops) ws\nvar sendOperation = function(client, operation) {\n  var operations = R.append(operation, client.operations);\n  var result = Core.integrateAll(operations, client.wString);\n\n  return updateWString(result.wString,\n    updateOperations(result.operations, client)\n  );\n};\n\nvar updateOperations = R.assoc('operations');\nvar updateWString = R.assoc('wString');\n//\n// sendOperations :: WootClient -> [Operation] -> WootClient\n// sendOperations = foldl sendOperation\n//\n//\n// -- identical to sendOperation, but increments the clients internal clock\n// -- not exposed - consumers should use sendLocalDelete or sendLocalInsert\n// sendLocalOperation :: WootClient -> Operation -> WootClient\n// sendLocalOperation client = incClock . sendOperation client\n//\n//\n// -- note: failed local operations can result in no-ops if the underlying operation is invalid\n// -- they will not be added to a client's operation queue\n// -- the assumption is that anything done locally should already be verified\n// -- if the local operation was successful, the operation should be broadcasted to other clients\n// sendLocalDelete :: WootClient -> Int -> (Maybe Operation, WootClient)\n// sendLocalDelete client pos = (op,) $ maybe client (sendLocalOperation client) op\n//   where\n//     op = makeDeleteOperation (wootClientId client) pos (wootClientString client)\n//\n//\n// sendLocalInsert :: WootClient -> Int -> Char -> (Maybe Operation, WootClient)\n// sendLocalInsert client@(WootClient cid clock ws _) pos a =\n//     (op,) $ maybe client (sendLocalOperation client) op\n//   where\n//     op = makeInsertOperation (WCharId cid clock) pos a ws\n\nmodule.exports = {\n  makeWootClient: makeWootClient,\n  makeWootClientEmpty: makeWootClientEmpty,\n  sendOperation: sendOperation\n}\n"],"sourceRoot":"/source/"}