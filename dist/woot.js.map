{"version":3,"sources":["woot.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qBAyBc,OAAO;;;;wBAEJ,aAAa;;;;2BACV,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBpC,IAAM,cAAc,GAAG,mBAAE,KAAK,CAAC,UAAC,OAAO,EAAE,QAAQ,EAAK;AACpD,SAAO;AACL,YAAQ,EAAE,QAAQ;AAClB,SAAK,EAAE,CAAC;AACR,WAAO,EAAE,OAAO;AAChB,kBAAc,EAAE,EAAE;GACnB,CAAC;CACH,CAAC,CAAC;;AAEH,IAAM,mBAAmB,GAAG,cAAc,CAAC,yBAAQ,gBAAgB,EAAE,CAAC,CAAC;;;;;;;AAOvE,IAAM,gBAAgB,GAAG,mBAAE,KAAK,CAAC,YAAY,CAAC,CAAC;AAC/C,IAAM,aAAa,GAAG,mBAAE,KAAK,CAAC,SAAS,CAAC,CAAC;;;;;;;;;AASzC,IAAM,aAAa,GAAG,SAAhB,aAAa,CAAI,MAAM,EAAE,SAAS,EAAK;AAC3C,MAAM,UAAU,GAAG,mBAAE,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,cAAc,CAAC,CAAC;AAC9D,MAAM,MAAM,GAAG,sBAAK,YAAY,CAAC,UAAU,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC;;AAE7D,SAAO,aAAa,CAAC,MAAM,CAAC,OAAO,EACjC,gBAAgB,CAAC,MAAM,CAAC,UAAU,EAAE,MAAM,CAAC,CAC5C,CAAC;CACH,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;qBA4Ba;AACb,gBAAc,EAAd,cAAc;AACd,qBAAmB,EAAnB,mBAAmB;AACnB,eAAa,EAAb,aAAa;CACd","file":"woot.js","sourcesContent":["// module Data.Woot\n//     ( WootClient\n//     , wootClientId\n//     , wootClientClock\n//     , wootClientString\n//     , wootClientOperationQueue\n//\n//     -- Construction\n//     , makeWootClient\n//     , makeWootClientEmpty\n//\n//     -- Operation handling\n//     , sendOperation\n//     , sendOperations\n//     , sendLocalDelete\n//     , sendLocalInsert\n//\n//     -- Useful data types from other modules\n//     , WString\n//     , WChar(..)\n//     , WCharId(..)\n//     , Operation(..)\n//     , ClientId\n//     ) where\n\nimport R from 'ramda';\n\nimport Core from './woot/core';\nimport WString from './woot/wstring';\n//\n// import Data.Woot.Core\n// import Data.Woot.Operation\n// import Data.Woot.WChar\n// import Data.Woot.WString\n//\n//\n// data WootClient = WootClient\n//     { wootClientId             :: Int\n//     , wootClientClock          :: Int\n//     , wootClientString         :: WString\n//     , wootClientOperationQueue :: [Operation]\n//     } deriving (Eq, Show)\n//\n//\n// incClock :: WootClient -> WootClient\n// incClock client = client {wootClientClock = succ $ wootClientClock client}\n//\n//\n// -- TODO: should this check is the client id already exists in the provided string\n// -- and then start the client clock at the correct value?\n// makeWootClient :: WString -> ClientId -> WootClient\n// makeWootClient ws cid = WootClient cid 0 ws []\nconst makeWootClient = R.curry((wString, clientId) => {\n  return {\n    clientId: clientId,\n    clock: 0,\n    wString: wString,\n    operationQueue: []\n  };\n});\n\nconst makeWootClientEmpty = makeWootClient(WString.makeEmptyWString());\n\n//\n// makeWootClientEmpty :: ClientId -> WootClient\n// makeWootClientEmpty = makeWootClient emptyWString\n//\n\nconst updateOperations = R.assoc('operations');\nconst updateWString = R.assoc('wString');\n//\n// -- sends an operation to a woot client, returning a new woot client\n// -- the operation will either be integrated into the woot client's string\n// -- or it will be added to the client's interal operation queue to be tried again\n// sendOperation :: WootClient -> Operation -> WootClient\n// sendOperation (WootClient cid clock ws ops) op = WootClient cid clock ws' ops'\n//     where\n//       (ops', ws') = integrateAll (op:ops) ws\nconst sendOperation = (client, operation) => {\n  const operations = R.append(operation, client.operationQueue);\n  const result = Core.integrateAll(operations, client.wString);\n\n  return updateWString(result.wString,\n    updateOperations(result.operations, client)\n  );\n};\n//\n// sendOperations :: WootClient -> [Operation] -> WootClient\n// sendOperations = foldl sendOperation\n//\n//\n// -- identical to sendOperation, but increments the clients internal clock\n// -- not exposed - consumers should use sendLocalDelete or sendLocalInsert\n// sendLocalOperation :: WootClient -> Operation -> WootClient\n// sendLocalOperation client = incClock . sendOperation client\n//\n//\n// -- note: failed local operations can result in no-ops if the underlying operation is invalid\n// -- they will not be added to a client's operation queue\n// -- the assumption is that anything done locally should already be verified\n// -- if the local operation was successful, the operation should be broadcasted to other clients\n// sendLocalDelete :: WootClient -> Int -> (Maybe Operation, WootClient)\n// sendLocalDelete client pos = (op,) $ maybe client (sendLocalOperation client) op\n//   where\n//     op = makeDeleteOperation (wootClientId client) pos (wootClientString client)\n//\n//\n// sendLocalInsert :: WootClient -> Int -> Char -> (Maybe Operation, WootClient)\n// sendLocalInsert client@(WootClient cid clock ws _) pos a =\n//     (op,) $ maybe client (sendLocalOperation client) op\n//   where\n//     op = makeInsertOperation (WCharId cid clock) pos a ws\n\nexport default {\n  makeWootClient,\n  makeWootClientEmpty,\n  sendOperation\n};\n"],"sourceRoot":"/source/"}