{"version":3,"sources":["woot/wstring.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0GA,IAAI,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;;AAEzB,IAAI,KAAK,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC;;AAE/B,IAAI,gBAAgB,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,aAAa,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC;;AAEzE,MAAM,CAAC,OAAO,GAAG;AACf,kBAAgB,EAAE,gBAAgB;CACnC,CAAC","file":"woot/wstring.js","sourcesContent":["// module Data.Woot.WString\n//     ( WString\n//     -- Construction\n//     , emptyWString\n//     , fromList\n//     , toList\n//\n//     -- General WString operations\n//     , lengthWS\n//     , (!?)\n//     , indexOf\n//     , insert\n//     , subsection\n//     , contains\n//     , isEmpty\n//     , nthVisible\n//\n//     -- Special utilities\n//     , hideChar\n//     ) where\n//\n//\n// import Data.Maybe\n// import qualified Data.Vector as V\n//\n// import Data.Woot.WChar\n//\n//\n// newtype WString = WString { wStringChars :: V.Vector WChar } deriving (Eq)\n//\n//\n// instance Show WString where\n//     -- get the visible characters, then remove any special characters\n//     -- TODO: this could be more efficient by composing (init . tail) in vector form\n//     -- (we know that the only special characters are at the beginning and end of the string)\n//     show = map wCharAlpha . toList . visibleChars\n//\n//\n// emptyWString :: WString\n// emptyWString = fromList [wCharBeginning, wCharEnding]\n//\n//\n// fromList :: [WChar] -> WString\n// fromList = WString . V.fromList\n//\n//\n// toList :: WString -> [WChar]\n// toList = V.toList . wStringChars\n//\n//\n// lengthWS :: WString -> Int\n// lengthWS = V.length . wStringChars\n//\n//\n// -- unsafe\n// (!) :: WString -> Int -> WChar\n// (!) ws n = wStringChars ws V.! n\n//\n//\n// (!?) :: WString -> Int -> Maybe WChar\n// (!?) ws n = wStringChars ws V.!? n\n//\n//\n// indexOf :: WCharId -> WString -> Maybe Int\n// indexOf wcid = V.findIndex ((==) wcid . wCharId) . wStringChars\n//\n//\n// -- insert before index i\n// -- insert 2 'x' \"abc\" -> abxc\n// insert :: WChar -> Int -> WString -> WString\n// insert wc i (WString wcs) = WString $ V.concat [V.take i wcs, V.singleton wc, V.drop i wcs]\n//\n//\n// -- returns the subsequence between the two provided elements, both not included\n// subsection :: WCharId -> WCharId -> WString -> WString\n// subsection prev next ws = WString . fromMaybe V.empty $ do\n//     i <- indexOf prev ws\n//     j <- indexOf next ws\n//     return $ slice' i (j - i) (wStringChars ws)\n//   where\n//     -- safe version of slice - returns empty when passed illegal indices\n//     slice' i n = V.take n . V.drop i\n//\n//\n// contains :: WCharId -> WString -> Bool\n// contains wcid ws = isJust $ indexOf wcid ws\n//\n//\n// visibleChars :: WString -> WString\n// visibleChars = WString . V.filter wCharVisible . wStringChars\n//\n//\n// nthVisible :: Int -> WString -> Maybe WChar\n// nthVisible n = (!? n) . visibleChars\n//\n//\n// isEmpty :: WString -> Bool\n// isEmpty = V.null . wStringChars\n//\n//\n// hideChar :: WCharId -> WString -> WString\n// hideChar wid ws@(WString wcs) = WString $\n//     maybe wcs (\\i -> wcs V.// [(i, hide $ ws ! i)]) mindex\n//   where\n//     mindex = indexOf wid ws\n\nvar R = require('ramda');\n\nvar WChar = require('./wchar');\n\nvar makeEmptyWString = R.always([WChar.beginningChar, WChar.endingChar]);\n\nmodule.exports = {\n  makeEmptyWString: makeEmptyWString\n};\n"],"sourceRoot":"/source/"}