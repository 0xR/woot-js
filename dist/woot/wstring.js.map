{"version":3,"sources":["woot/wstring.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qBAiCc,OAAO;;;;qBAEH,SAAS;;;;;AAG3B,IAAM,gBAAgB,GAAG,mBAAE,MAAM,CAAC,CAAC,mBAAM,aAAa,EAAE,mBAAM,UAAU,CAAC,CAAC,CAAC;;;AAG3E,IAAM,eAAe,GAAG,mBAAE,MAAM,CAAC,mBAAE,MAAM,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,CAAC;;;AAG9D,IAAM,IAAI,GAAG,mBAAE,OAAO,CACpB,mBAAE,IAAI,CAAC,EAAE,CAAC,EACV,mBAAE,KAAK,CAAC,OAAO,CAAC,EAChB,eAAe,CAChB,CAAC;;;;;AAKF,IAAM,MAAM,GAAG,mBAAE,MAAM,CAAC;;;AAIxB,IAAM,OAAO,GAAG,SAAV,OAAO,CAAI,EAAE,EAAE,OAAO,EAAK;AAC/B,MAAM,KAAK,GAAG,mBAAE,SAAS,CAAC,mBAAE,MAAM,CAAC,IAAI,EAAE,EAAE,CAAC,EAAE,OAAO,CAAC,CAAC;AACvD,SAAO,KAAK,KAAK,CAAC,CAAC,GAAG,IAAI,GAAG,KAAK,CAAC;CACpC,CAAC;;;AAGF,IAAM,QAAQ,GAAG,SAAX,QAAQ,CAAI,EAAE,EAAE,OAAO,EAAK;AAChC,SAAO,OAAO,CAAC,EAAE,EAAE,OAAO,CAAC,KAAK,IAAI,CAAC;CACtC,CAAC;;;AAGF,IAAM,UAAU,GAAG,SAAb,UAAU,CAAI,GAAG,EAAE,GAAG,EAAE,OAAO,EAAK;AACxC,MAAM,MAAM,GAAG,OAAO,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;AACrC,MAAM,MAAM,GAAG,OAAO,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;;AAErC,MAAI,MAAM,IAAI,MAAM,IAAK,MAAM,GAAG,MAAM,AAAC,EAAE;AACzC,WAAO,mBAAE,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;GAC7C;;AAED,SAAO,EAAE,CAAC;CACX,CAAC;;;AAIF,IAAM,QAAQ,GAAG,SAAX,QAAQ,CAAI,EAAE,EAAE,OAAO,EAAK;AAChC,MAAM,KAAK,GAAG,OAAO,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;AACnC,MAAM,KAAK,GAAG,mBAAM,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;;AAEzC,SAAO,KAAK,GAAG,mBAAE,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,GAAG,OAAO,CAAC;CAC1D,CAAC;;;;;;qBAMa;AACb,kBAAgB,EAAhB,gBAAgB;AAChB,MAAI,EAAJ,IAAI;AACJ,QAAM,EAAN,MAAM;AACN,YAAU,EAAV,UAAU;AACV,UAAQ,EAAR,QAAQ;AACR,SAAO,EAAP,OAAO;AACP,UAAQ,EAAR,QAAQ;CACT","file":"woot/wstring.js","sourcesContent":["// module Data.Woot.WString\n//     ( WString\n//     -- Construction\n//     , emptyWString\n//     , fromList\n//     , toList\n//\n//     -- General WString operations\n//     , lengthWS\n//     , (!?)\n//     , indexOf\n//     , insert\n//     , subsection\n//     , contains\n//     , isEmpty\n//     , nthVisible\n//\n//     -- Special utilities\n//     , hideChar\n//     ) where\n//\n//\n// nthVisible :: Int -> WString -> Maybe WChar\n// nthVisible n = (!? n) . visibleChars\n//\n//\n//\n// hideChar :: WCharId -> WString -> WString\n// hideChar wid ws@(WString wcs) = WString $\n//     maybe wcs (\\i -> wcs V.// [(i, hide $ ws ! i)]) mindex\n//   where\n//     mindex = indexOf wid ws\n\nimport R from 'ramda';\n\nimport WChar from './wchar';\n\n// makeEmptyWString :: WString\nconst makeEmptyWString = R.always([WChar.beginningChar, WChar.endingChar]);\n\n// getVisibleChars :: WString -> WString\nconst getVisibleChars = R.filter(R.propEq('isVisible', true));\n\n// show :: WString -> String\nconst show = R.compose(\n  R.join(''),\n  R.pluck('alpha'),\n  getVisibleChars\n);\n\n// -- insert before index i\n// -- insert 2 'x' \"abc\" -> abxc\n// insert :: Int -> WChar -> WString -> WString\nconst insert = R.insert;\n\n\n// indexOf :: WCharId -> WString -> Int | null\nconst indexOf = (id, wString) => {\n  const index = R.findIndex(R.propEq('id', id), wString);\n  return index === -1 ? null : index;\n};\n\n// contains :: WCharId -> WString -> Bool\nconst contains = (id, wString) => {\n  return indexOf(id, wString) !== null;\n};\n\n// subsection :: WCharId -> WCharId -> WString -> WString\nconst subsection = (idA, idB, wString) => {\n  const indexA = indexOf(idA, wString);\n  const indexB = indexOf(idB, wString);\n\n  if (indexA && indexB && (indexA < indexB)) {\n    return R.slice(indexA + 1, indexB, wString);\n  }\n\n  return [];\n};\n\n\n// hideChar :: WCharId -> WString -> WString\nconst hideChar = (id, wString) => {\n  const index = indexOf(id, wString);\n  const wChar = WChar.hide(wString[index]);\n\n  return index ? R.update(index, wChar, wString) : wString;\n};\n// hideChar wid ws@(WString wcs) = WString $\n//     maybe wcs (\\i -> wcs V.// [(i, hide $ ws ! i)]) mindex\n//   where\n//     mindex = indexOf wid ws\n\nexport default {\n  makeEmptyWString,\n  show,\n  insert,\n  subsection,\n  contains,\n  indexOf,\n  hideChar\n};\n"],"sourceRoot":"/source/"}