{"version":3,"sources":["woot/wstring.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qBA0Gc,OAAO;;;;qBAEH,SAAS;;;;AAE3B,IAAM,gBAAgB,GAAG,mBAAE,MAAM,CAAC,CAAC,mBAAM,aAAa,EAAE,mBAAM,UAAU,CAAC,CAAC,CAAC;;AAE3E,IAAM,eAAe,GAAG,mBAAE,MAAM,CAAC,mBAAE,MAAM,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,CAAC;;AAE9D,IAAM,IAAI,GAAG,mBAAE,OAAO,CACpB,mBAAE,IAAI,CAAC,EAAE,CAAC,EACV,mBAAE,KAAK,CAAC,OAAO,CAAC,EAChB,eAAe,CAChB,CAAC;;AAEF,IAAM,MAAM,GAAG,mBAAE,MAAM,CAAC;;AAExB,IAAM,UAAU,GAAG,SAAb,UAAU,CAAI,GAAG,EAAE,GAAG,EAAE,OAAO,EAAK;AACxC,MAAM,MAAM,GAAG,mBAAE,SAAS,CAAC,mBAAE,MAAM,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE,OAAO,CAAC,CAAC;AACzD,MAAM,MAAM,GAAG,mBAAE,SAAS,CAAC,mBAAE,MAAM,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE,OAAO,CAAC,CAAC;;AAEzD,MAAI,MAAM,KAAK,CAAC,CAAC,IAAK,MAAM,GAAG,MAAM,AAAC,EAAE;AACtC,WAAO,mBAAE,KAAK,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;GACzC;;AAED,SAAO,EAAE,CAAC;CACX,CAAC;;qBAEa;AACb,kBAAgB,EAAhB,gBAAgB;AAChB,MAAI,EAAJ,IAAI;AACJ,QAAM,EAAN,MAAM;AACN,YAAU,EAAV,UAAU;CACX","file":"woot/wstring.js","sourcesContent":["// module Data.Woot.WString\n//     ( WString\n//     -- Construction\n//     , emptyWString\n//     , fromList\n//     , toList\n//\n//     -- General WString operations\n//     , lengthWS\n//     , (!?)\n//     , indexOf\n//     , insert\n//     , subsection\n//     , contains\n//     , isEmpty\n//     , nthVisible\n//\n//     -- Special utilities\n//     , hideChar\n//     ) where\n//\n//\n// import Data.Maybe\n// import qualified Data.Vector as V\n//\n// import Data.Woot.WChar\n//\n//\n// newtype WString = WString { wStringChars :: V.Vector WChar } deriving (Eq)\n//\n//\n// instance Show WString where\n//     -- get the visible characters, then remove any special characters\n//     -- TODO: this could be more efficient by composing (init . tail) in vector form\n//     -- (we know that the only special characters are at the beginning and end of the string)\n//     show = map wCharAlpha . toList . visibleChars\n//\n//\n// emptyWString :: WString\n// emptyWString = fromList [wCharBeginning, wCharEnding]\n//\n//\n// fromList :: [WChar] -> WString\n// fromList = WString . V.fromList\n//\n//\n// toList :: WString -> [WChar]\n// toList = V.toList . wStringChars\n//\n//\n// lengthWS :: WString -> Int\n// lengthWS = V.length . wStringChars\n//\n//\n// -- unsafe\n// (!) :: WString -> Int -> WChar\n// (!) ws n = wStringChars ws V.! n\n//\n//\n// (!?) :: WString -> Int -> Maybe WChar\n// (!?) ws n = wStringChars ws V.!? n\n//\n//\n// indexOf :: WCharId -> WString -> Maybe Int\n// indexOf wcid = V.findIndex ((==) wcid . wCharId) . wStringChars\n//\n//\n// -- insert before index i\n// -- insert 2 'x' \"abc\" -> abxc\n// insert :: WChar -> Int -> WString -> WString\n// insert wc i (WString wcs) = WString $ V.concat [V.take i wcs, V.singleton wc, V.drop i wcs]\n//\n//\n// -- returns the subsequence between the two provided elements, both not included\n// subsection :: WCharId -> WCharId -> WString -> WString\n// subsection prev next ws = WString . fromMaybe V.empty $ do\n//     i <- indexOf prev ws\n//     j <- indexOf next ws\n//     return $ slice' i (j - i) (wStringChars ws)\n//   where\n//     -- safe version of slice - returns empty when passed illegal indices\n//     slice' i n = V.take n . V.drop i\n//\n//\n// contains :: WCharId -> WString -> Bool\n// contains wcid ws = isJust $ indexOf wcid ws\n//\n//\n// visibleChars :: WString -> WString\n// visibleChars = WString . V.filter wCharVisible . wStringChars\n//\n//\n// nthVisible :: Int -> WString -> Maybe WChar\n// nthVisible n = (!? n) . visibleChars\n//\n//\n// isEmpty :: WString -> Bool\n// isEmpty = V.null . wStringChars\n//\n//\n// hideChar :: WCharId -> WString -> WString\n// hideChar wid ws@(WString wcs) = WString $\n//     maybe wcs (\\i -> wcs V.// [(i, hide $ ws ! i)]) mindex\n//   where\n//     mindex = indexOf wid ws\n\nimport R from 'ramda';\n\nimport WChar from './wchar';\n\nconst makeEmptyWString = R.always([WChar.beginningChar, WChar.endingChar]);\n\nconst getVisibleChars = R.filter(R.propEq('isVisible', true));\n\nconst show = R.compose(\n  R.join(''),\n  R.pluck('alpha'),\n  getVisibleChars\n);\n\nconst insert = R.insert;\n\nconst subsection = (idA, idB, wString) => {\n  const indexA = R.findIndex(R.propEq('id', idA), wString);\n  const indexB = R.findIndex(R.propEq('id', idB), wString);\n\n  if (indexA !== -1 && (indexA < indexB)) {\n    return R.slice(indexA, indexB, wString);\n  }\n\n  return [];\n};\n\nexport default {\n  makeEmptyWString,\n  show,\n  insert,\n  subsection\n};\n"],"sourceRoot":"/source/"}