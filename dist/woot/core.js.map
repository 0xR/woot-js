{"version":3,"sources":["woot/core.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAcA,IAAI,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;;;;AAIzB,IAAI,SAAS,GAAG,SAAZ,SAAS,CAAY,SAAS,EAAE,OAAO,EAAE;AAC3C,SAAO,YAAY,CAAC,SAAS,EAAE,OAAO,CAAC,GAAG,WAAW,CAAC,SAAS,EAAE,EAAE,CAAC,GAAG,IAAI,CAAC;CAC7E,CAAA;;;;;;;;;;;;AAYD,IAAI,YAAY,GAAG,SAAf,YAAY,CAAY,SAAS,EAAE,OAAO,EAAE,EAE/C,CAAC;;;;;;AAMF,IAAI,YAAY,GAAG,kBAAkB,CAAC;AACpC,QAAM,EAAE,gBAAS,SAAS,EAAE,OAAO,EAAE;AACnC,QAAI,YAAY,GAAG,OAAO,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AACrE,QAAI,YAAY,GAAG,OAAO,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AACrE,WAAO,YAAY,IAAI,YAAY,CAAC;GACrC;AACD,YAAQ,iBAAS,SAAS,EAAE,OAAO,EAAE;AACnC,WAAO,OAAO,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;GACtD;CACF,CAAC,CAAC;;;;;AAKH,IAAI,WAAW,GAAG,kBAAkB,CAAC;AACnC,QAAM,EAAE,gBAAS,SAAS,EAAE,OAAO,EAAE;AACnC,WAAO,eAAe,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,EAAE,SAAS,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;GACjF;AACD,YAAQ,iBAAS,SAAS,EAAE,OAAO,EAAE;AACnC,WAAO,eAAe,CAAC,SAAS,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;GAClD;CACF,CAAC,CAAC;;AAEH,IAAI,kBAAkB,GAAG,SAArB,kBAAkB,CAAY,IAAI,EAAE;AACtC,SAAO,UAAS,SAAS,EAAE;AACzB,QAAI,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE;AAC/B,aAAO,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;KAC5D,MAAM;AACL,YAAM,IAAI,KAAK,CAAC,0BAA0B,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC;KAC9D;GACF,CAAC;CACH,CAAC","file":"woot/core.js","sourcesContent":["// module Data.Woot.Core\n//     ( integrate\n//     , integrateAll\n//     , makeDeleteOperation\n//     , makeInsertOperation\n//     ) where\n//\n//\n// import Control.Applicative -- keep for ghc <7.10\n// import Data.Maybe (fromJust)\n//\n// import Data.Woot.Operation\n// import Data.Woot.WChar\n// import Data.Woot.WString\nvar R = require('ramda');\n//\n// integrate :: Operation -> WString -> Maybe WString\n// integrate op ws = if canIntegrate op ws then Just $ integrateOp op ws else Nothing\nvar integrate = function(operation, wString) {\n  return canIntegrate(operation, wString) ? integrateOp(operation, ws) : null;\n}\n//\n// -- iterate through operation list until stable\n// -- return any remaining operations, along with new string\n// integrateAll :: [Operation] -> WString -> ([Operation], WString)\n// integrateAll ops ws = if length ops == length newOps then result\n//     else integrateAll newOps newString\n//   where\n//     result@(newOps, newString)  = foldl integrate' ([], ws) ops\n//     integrate' (ops', s) op = maybe (ops' ++ [op], s) (ops',) (integrate op s)\n\n// integrateAll :: [Operation] -> WString -> ([Operation], WString)\nvar integrateAll = function(operation, wString) {\n\n};\n\n//\n// canIntegrate :: Operation -> WString -> Bool\n// canIntegrate (Operation Insert _ wc) ws = all (`contains` ws) [wCharPrevId wc, wCharNextId wc]\n// canIntegrate (Operation Delete _ wc) ws = contains (wCharId wc) ws\nvar canIntegrate = matchOperationType({\n  insert: function(operation, wString) {\n    var containsPrev = WString.contains(operation.wChar.prevId, wString);\n    var containsNext = WString.contains(operation.wChar.nextId, wString);\n    return containsPrev && containsNext;\n  },\n  delete: function(operation, wString) {\n    return WString.contains(operation.wChar.id, wString);\n  }\n});\n\n// integrateOp :: Operation -> WString -> WString\n// integrateOp (Operation Insert _ wc) ws = integrateInsert (wCharPrevId wc) (wCharNextId wc) wc ws\n// integrateOp (Operation Delete _ wc) ws = integrateDelete wc ws\nvar integrateOp = matchOperationType({\n  insert: function(operation, wString) {\n    return integrateInsert(operation.wChar.prevId, operation.wChar.nextId, wString);\n  },\n  delete: function(operation, wString) {\n    return integrateDelete(operation.wChar, wString);\n  }\n});\n\nvar matchOperationType = function(dict) {\n  return function(operation) {\n    if (R.has(operation.type, dict)) {\n      return R.prop(operation.type, dict).apply(null, arguments);\n    } else {\n      throw new Error('Invalid operation type: ' + operation.type);\n    }\n  };\n};\n//\n// integrateInsert :: WCharId -> WCharId -> WChar -> WString -> WString\n// -- if char already exists\n// integrateInsert _ _ wc ws | contains (wCharId wc) ws = ws\n// integrateInsert prevId nextId wc ws = if isEmpty sub\n//     -- should always be safe to get index and insert since we have flagged this as 'canIntegrate'\n//     then insert wc (fromJust $ indexOf nextId ws) ws\n//     else compareIds $ map wCharId (toList sub) ++ [nextId]\n//   where\n//     sub = subsection prevId nextId ws\n//     compareIds :: [WCharId] -> WString\n//     -- current id is less than the previous id\n//     compareIds (wid:_) | wCharId wc < wid = insert wc (fromJust $ indexOf wid ws) ws\n//      -- recurse to integrateInsert with next id in the subsection\n//     compareIds (_:wid:_) = integrateInsert wid nextId wc ws\n//     -- should never have a match fall through to here, but for good measure...\n//     compareIds _  = ws\n//\n//\n// integrateDelete :: WChar -> WString -> WString\n// integrateDelete wc = hideChar (wCharId wc)\n//\n//\n// makeDeleteOperation :: ClientId -> Int -> WString -> Maybe Operation\n// makeDeleteOperation cid pos ws = Operation Delete cid <$> nthVisible pos ws\n//\n//\n// -- position based of off visible characters only\n// -- operations should only be concerned with the visible string\n// makeInsertOperation :: WCharId -> Int -> Char -> WString -> Maybe Operation\n// makeInsertOperation (WCharId cid clock) pos a ws = Operation Insert cid <$> do\n//     let numVis = length $ show ws\n//\n//     -- first check if we are trying to insert at the very beginning of the string\n//     prev <- if pos == 0 then beginningChar else nthVisible (pos - 1) ws\n//\n//     -- also see if the insert is being done at the very end of the string\n//     next <- if pos == numVis then endingChar else nthVisible pos ws\n//     return $ WChar (WCharId cid clock) True a (wCharId prev) (wCharId next)\n//   where\n//     beginningChar = ws !? 0\n//     endingChar = ws !? (lengthWS ws - 1)\n"],"sourceRoot":"/source/"}