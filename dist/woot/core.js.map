{"version":3,"sources":["woot/core.js"],"names":[],"mappings":"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","file":"woot/core.js","sourcesContent":["// module Data.Woot.Core\n//     ( integrate\n//     , integrateAll\n//     , makeDeleteOperation\n//     , makeInsertOperation\n//     ) where\n//\n//\n// import Control.Applicative -- keep for ghc <7.10\n// import Data.Maybe (fromJust)\n//\n// import Data.Woot.Operation\n// import Data.Woot.WChar\n// import Data.Woot.WString\nimport R from 'ramda';\n\nimport WString from './wstring';\n\n// matchOperationType :: {OperationType: *} -> (Operation -> * | Error)\nconst matchOperationType = (dict) => {\n  return (...args) => {\n    const type = R.path(['0', 'type'], args);\n    if (R.has(type, dict)) {\n      return R.prop(type, dict).apply(null, args);\n    }\n\n    throw new Error('Invalid operation type: ' + type);\n  };\n};\n\n// canIntegrate :: Operation -> WString -> Bool\nconst canIntegrate = matchOperationType({\n  insert: (wChar, wString) => {\n    const containsPrev = WString.contains(wChar.prevId, wString);\n    const containsNext = WString.contains(wChar.nextId, wString);\n    return containsPrev && containsNext;\n  },\n  'delete': ({wChar}, wString) => {\n    return WString.contains(wChar.id, wString);\n  }\n});\n\n\n// integrateOp :: Operation -> WString -> WString\nconst integrateOp = matchOperationType({\n  insert: ({wChar}, wString) => {\n    return integrateInsert(wChar.prevId, wChar.nextId, wString);\n  },\n  'delete': ({wChar}, wString) => {\n    return integrateDelete(wChar, wString);\n  }\n});\n\n// integrate :: Operation -> WString -> WString | null\nconst integrate = (operation, wString) => {\n  return canIntegrate(operation, wString) ? integrateOp(operation, wString) : null;\n};\n\n//\n// -- iterate through operation list until stable\n// -- return any remaining operations, along with new string\n// integrateAll :: [Operation] -> WString -> ([Operation], WString)\n// integrateAll ops ws = if length ops == length newOps then result\n//     else integrateAll newOps newString\n//   where\n//     result@(newOps, newString)  = foldl integrate' ([], ws) ops\n//     integrate' (ops', s) op = maybe (ops' ++ [op], s) (ops',) (integrate op s)\n\n// integrateAll :: [Operation] -> WString -> ([Operation], WString)\nconst integrateAll = function(operations, wString) {\n  const integrate_ = ([ops, s], op) => {\n    const res = integrate(op, s);\n    return res ? [ops, res] : [R.append(op, ops), s];\n  };\n\n  const [newOps, s] = R.reduce(integrate_, [[], wString], operations);\n\n  return R.length(operations) === R.length(newOps) ? [newOps, s] : integrateAll(newOps, s);\n};\n\n\n//\n// integrateInsert :: WCharId -> WCharId -> WChar -> WString -> WString\n// -- if char already exists\n// integrateInsert _ _ wc ws | contains (wCharId wc) ws = ws\n// integrateInsert prevId nextId wc ws = if isEmpty sub\n//     -- should always be safe to get index and insert since we have flagged this as 'canIntegrate'\n//     then insert wc (fromJust $ indexOf nextId ws) ws\n//     else compareIds $ map wCharId (toList sub) ++ [nextId]\n//   where\n//     sub = subsection prevId nextId ws\n//     compareIds :: [WCharId] -> WString\n//     -- current id is less than the previous id\n//     compareIds (wid:_) | wCharId wc < wid = insert wc (fromJust $ indexOf wid ws) ws\n//      -- recurse to integrateInsert with next id in the subsection\n//     compareIds (_:wid:_) = integrateInsert wid nextId wc ws\n//     -- should never have a match fall through to here, but for good measure...\n//     compareIds _  = ws\n//\n//\n// integrateDelete :: WChar -> WString -> WString\n// integrateDelete wc = hideChar (wCharId wc)\n//\n//\n// makeDeleteOperation :: ClientId -> Int -> WString -> Maybe Operation\n// makeDeleteOperation cid pos ws = Operation Delete cid <$> nthVisible pos ws\n//\n//\n// -- position based of off visible characters only\n// -- operations should only be concerned with the visible string\n// makeInsertOperation :: WCharId -> Int -> Char -> WString -> Maybe Operation\n// makeInsertOperation (WCharId cid clock) pos a ws = Operation Insert cid <$> do\n//     let numVis = length $ show ws\n//\n//     -- first check if we are trying to insert at the very beginning of the string\n//     prev <- if pos == 0 then beginningChar else nthVisible (pos - 1) ws\n//\n//     -- also see if the insert is being done at the very end of the string\n//     next <- if pos == numVis then endingChar else nthVisible pos ws\n//     return $ WChar (WCharId cid clock) True a (wCharId prev) (wCharId next)\n//   where\n//     beginningChar = ws !? 0\n//     endingChar = ws !? (lengthWS ws - 1)\n\nexport default {\n  integrate,\n  integrateAll\n};\n"],"sourceRoot":"/source/"}