{"version":3,"sources":["woot/core.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;qBAcc,OAAO;;;;uBAED,WAAW;;;;qBACb,SAAS;;;;;AAG3B,IAAM,kBAAkB,GAAG,SAArB,kBAAkB,CAAI,IAAI,EAAK;AACnC,SAAO,YAAa;sCAAT,IAAI;AAAJ,UAAI;;;AACb,QAAM,IAAI,GAAG,mBAAE,IAAI,CAAC,CAAC,GAAG,EAAE,MAAM,CAAC,EAAE,IAAI,CAAC,CAAC;AACzC,QAAI,mBAAE,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE;AACrB,aAAO,mBAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;KAC7C;;AAED,UAAM,IAAI,KAAK,CAAC,0BAA0B,GAAG,IAAI,CAAC,CAAC;GACpD,CAAC;CACH,CAAC;;;AAGF,IAAM,YAAY,GAAG,kBAAkB,CAAC;AACtC,QAAM,EAAE,gBAAC,IAAO,EAAE,OAAO,EAAK;QAApB,KAAK,GAAN,IAAO,CAAN,KAAK;;AACb,QAAM,YAAY,GAAG,qBAAQ,QAAQ,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AAC7D,QAAM,YAAY,GAAG,qBAAQ,QAAQ,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AAC7D,WAAO,YAAY,IAAI,YAAY,CAAC;GACrC;AACD,UAAQ,EAAE,iBAAC,KAAO,EAAE,OAAO,EAAK;QAApB,KAAK,GAAN,KAAO,CAAN,KAAK;;AACf,WAAO,qBAAQ,QAAQ,CAAC,KAAK,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;GAC5C;CACF,CAAC,CAAC;;;AAIH,IAAM,WAAW,GAAG,kBAAkB,CAAC;AACrC,QAAM,EAAE,gBAAC,KAAO,EAAE,OAAO,EAAK;QAApB,KAAK,GAAN,KAAO,CAAN,KAAK;;AACb,WAAO,eAAe,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,MAAM,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;GACpE;AACD,UAAQ,EAAE,iBAAC,KAAO,EAAE,OAAO,EAAK;QAApB,KAAK,GAAN,KAAO,CAAN,KAAK;;AACf,WAAO,eAAe,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;GACxC;CACF,CAAC,CAAC;;;AAGH,IAAM,SAAS,GAAG,SAAZ,SAAS,CAAI,SAAS,EAAE,OAAO,EAAK;AACxC,SAAO,YAAY,CAAC,SAAS,EAAE,OAAO,CAAC,GAAG,WAAW,CAAC,SAAS,EAAE,OAAO,CAAC,GAAG,IAAI,CAAC;CAClF,CAAC;;;;;;;;;;;;;AAaF,IAAM,YAAY,GAAG,SAAf,YAAY;;;4BAAiC;QAArB,UAAU;QAAE,OAAO;AACzC,cAAU,4BAKT,MAAM,GAAE,CAAC;;;AALhB,QAAM,UAAU,GAAG,SAAb,UAAU,CAAI,KAAQ,EAAE,EAAE,EAAK;kCAAjB,KAAQ;;UAAP,GAAG;UAAE,CAAC;;AACzB,UAAM,GAAG,GAAG,SAAS,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC7B,aAAO,GAAG,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,CAAC,mBAAE,MAAM,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;KAClD,CAAC;;oBAEkB,mBAAE,MAAM,CAAC,UAAU,EAAE,CAAC,EAAE,EAAE,OAAO,CAAC,EAAE,UAAU,CAAC;;;;QAA5D,MAAM;QAAE,CAAC;AAET,QAAA,mBAAE,MAAM,CAAC,UAAU,CAAC,KAAK,mBAAE,MAAM,CAAC,MAAM,CAAC;aAAG,CAAC,MAAM,EAAE,CAAC,CAAC;;WAAgB,MAAM;YAAE,CAAC;;;KAAC;GACzF;CAAA,CAAC;;;;AAKF,IAAM,eAAe,GAAG,SAAlB,eAAe;;;8BAAuC;QAAnC,MAAM;QAAE,MAAM;QAAE,KAAK;QAAE,OAAO;AAK/C,cAAU,GAGR,KAAK,GAML,KAAK,GAKP,SAAS;;;AAlBf,QAAI,qBAAQ,QAAQ,CAAC,KAAK,CAAC,EAAE,EAAE,OAAO,CAAC,EAAE;AACvC,aAAO,OAAO,CAAC;KAChB;;AAED,QAAM,UAAU,GAAG,qBAAQ,UAAU,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;;AAE/D,QAAI,mBAAE,OAAO,CAAC,UAAU,CAAC,EAAE;AACzB,UAAM,KAAK,GAAG,qBAAQ,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AAC/C,aAAO,qBAAQ,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;KAC9C;;;AAGD,QAAI,mBAAM,eAAe,CAAC,KAAK,CAAC,EAAE,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE;AAClD,UAAM,KAAK,GAAG,qBAAQ,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AAC/C,aAAO,qBAAQ,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;KAC9C;;;AAGD,QAAM,SAAS,GAAG,mBAAE,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE,CAAC;UACjB,SAAS;UAAE,MAAM;UAAE,KAAK;UAAE,OAAO;;;GACzD;CAAA,CAAC;;;;;AAKF,IAAM,eAAe,GAAG,SAAlB,eAAe,CAAI,KAAI,EAAE,OAAO,EAAK;MAAjB,EAAE,GAAH,KAAI,CAAH,EAAE;;AAC1B,SAAO,qBAAQ,QAAQ,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;CACtC,CAAC;;;;;;;;;;;;;;;;;;;;;;qBAsBa;AACb,WAAS,EAAT,SAAS;AACT,cAAY,EAAZ,YAAY;CACb","file":"woot/core.js","sourcesContent":["// module Data.Woot.Core\n//     ( integrate\n//     , integrateAll\n//     , makeDeleteOperation\n//     , makeInsertOperation\n//     ) where\n//\n//\n// import Control.Applicative -- keep for ghc <7.10\n// import Data.Maybe (fromJust)\n//\n// import Data.Woot.Operation\n// import Data.Woot.WChar\n// import Data.Woot.WString\nimport R from 'ramda';\n\nimport WString from './wstring';\nimport WChar from './wchar';\n\n// matchOperationType :: {OperationType: *} -> (Operation -> * | Error)\nconst matchOperationType = (dict) => {\n  return (...args) => {\n    const type = R.path(['0', 'type'], args);\n    if (R.has(type, dict)) {\n      return R.prop(type, dict).apply(null, args);\n    }\n\n    throw new Error('Invalid operation type: ' + type);\n  };\n};\n\n// canIntegrate :: Operation -> WString -> Bool\nconst canIntegrate = matchOperationType({\n  insert: ({wChar}, wString) => {\n    const containsPrev = WString.contains(wChar.prevId, wString);\n    const containsNext = WString.contains(wChar.nextId, wString);\n    return containsPrev && containsNext;\n  },\n  'delete': ({wChar}, wString) => {\n    return WString.contains(wChar.id, wString);\n  }\n});\n\n\n// integrateOp :: Operation -> WString -> WString\nconst integrateOp = matchOperationType({\n  insert: ({wChar}, wString) => {\n    return integrateInsert(wChar.prevId, wChar.nextId, wChar, wString);\n  },\n  'delete': ({wChar}, wString) => {\n    return integrateDelete(wChar, wString);\n  }\n});\n\n// integrate :: Operation -> WString -> WString | null\nconst integrate = (operation, wString) => {\n  return canIntegrate(operation, wString) ? integrateOp(operation, wString) : null;\n};\n\n//\n// -- iterate through operation list until stable\n// -- return any remaining operations, along with new string\n// integrateAll :: [Operation] -> WString -> ([Operation], WString)\n// integrateAll ops ws = if length ops == length newOps then result\n//     else integrateAll newOps newString\n//   where\n//     result@(newOps, newString)  = foldl integrate' ([], ws) ops\n//     integrate' (ops', s) op = maybe (ops' ++ [op], s) (ops',) (integrate op s)\n\n// integrateAll :: [Operation] -> WString -> ([Operation], WString)\nconst integrateAll = function(operations, wString) {\n  const integrate_ = ([ops, s], op) => {\n    const res = integrate(op, s);\n    return res ? [ops, res] : [R.append(op, ops), s];\n  };\n\n  const [newOps, s] = R.reduce(integrate_, [[], wString], operations);\n\n  return R.length(operations) === R.length(newOps) ? [newOps, s] : integrateAll(newOps, s);\n};\n\n\n//\n// integrateInsert :: WCharId -> WCharId -> WChar -> WString -> WString\nconst integrateInsert = (prevId, nextId, wChar, wString) => {\n  if (WString.contains(wChar.id, wString)) {\n    return wString;\n  }\n\n  const subsection = WString.subsection(prevId, nextId, wString);\n\n  if (R.isEmpty(subsection)) {\n    const index = WString.indexOf(nextId, wString);\n    return WString.insert(index, wChar, wString);\n  }\n\n  // if the current char id is less than the previous id\n  if (WChar.compareWCharIds(wChar.id, prevId) === -1) {\n    const index = WString.indexOf(prevId, wString);\n    return WString.insert(index, wChar, wString);\n  }\n\n  // recurse to integrateInsert with next id in the subsection\n  const newPrevId = R.head(subsection).id;\n  return integrateInsert(newPrevId, nextId, wChar, wString);\n};\n\n//\n//\n// integrateDelete :: WChar -> WString -> WString\nconst integrateDelete = ({id}, wString) => {\n  return WString.hideChar(id, wString);\n};\n//\n// makeDeleteOperation :: ClientId -> Int -> WString -> Maybe Operation\n// makeDeleteOperation cid pos ws = Operation Delete cid <$> nthVisible pos ws\n//\n//\n// -- position based of off visible characters only\n// -- operations should only be concerned with the visible string\n// makeInsertOperation :: WCharId -> Int -> Char -> WString -> Maybe Operation\n// makeInsertOperation (WCharId cid clock) pos a ws = Operation Insert cid <$> do\n//     let numVis = length $ show ws\n//\n//     -- first check if we are trying to insert at the very beginning of the string\n//     prev <- if pos == 0 then beginningChar else nthVisible (pos - 1) ws\n//\n//     -- also see if the insert is being done at the very end of the string\n//     next <- if pos == numVis then endingChar else nthVisible pos ws\n//     return $ WChar (WCharId cid clock) True a (wCharId prev) (wCharId next)\n//   where\n//     beginningChar = ws !? 0\n//     endingChar = ws !? (lengthWS ws - 1)\n\nexport default {\n  integrate,\n  integrateAll\n};\n"],"sourceRoot":"/source/"}