import R from 'ramda';

import type {Ordering} from '../types/ordering';

export type WCharId = {
  clientId: number,
  clock: number,
};


export type WChar = {
  id: WCharId,
  isVisible: boolean,
  alpha: string,
  prevId: WCharId,
  prevId: WCharId,
};

// TODO: remove 'make<X> functions' once everything is typed
export const makeWChar: (_:Object) => WChar
= R.identity;


export const makeWCharId: (_:number, _:number) => WCharId
= (clientId, clock) => {
  return {clientId, clock};
};


const wCharIdBeginning: WCharId = makeWCharId(-1, 0);
const wCharIdEnding: WCharId = makeWCharId(-1, 1);


// -- special character to mark the beginning of a wString
// -- note: clientId of -1 denotes a special character generated by this library
// -- includes a self-referential 'prevId' field
export const wCharBeginning = {
  id: wCharIdBeginning,
  isVisible: false,
  alpha: ' ',
  prevId: wCharIdBeginning,
  nextId: wCharIdEnding,
};


// -- special character to mark the ending of a wString
// -- note: clientId of -1 denotes a special character generated by this library
// -- includes a self-referential 'nextId' field
export const wCharEnding = {
  id: wCharIdEnding,
  isVisible: false,
  alpha: ' ',
  prevId: wCharIdBeginning,
  nextId: wCharIdEnding,
};


export const hide: (_:WChar) => WChar
= R.assoc('isVisible', false);


// compareCharIds :: WCharId -> WCharId -> Ordering (-1, 0, 1)
export const compareWCharIds: (_:WCharId, _:WCharId) => Ordering
= (idA, idB) => {
  if (idA.clientId === idB.clientId) {
    if (idA.clock === idB.clock) {
      return 0;
    }

    return idA.clock < idB.clock ? -1 : 1;
  }

  return idA.clientId < idB.clientId ? -1 : 1;
};
