import R from 'ramda';
import V from 'o-validator';


const wCharIdSchema = {
  clientId: V.required(R.is(Number)),
  clock: V.required(R.is(Number))
};


const wCharSchema = {
  id: V.required(V.validate(wCharIdSchema)),
  isVisible: V.required(R.is(Boolean)),
  alpha: V.required(R.is(String)),
  prevId: V.required(V.validate(wCharIdSchema)),
  nextId: V.required(V.validate(wCharIdSchema))
};


// makeWCharId :: {k: a} -> WCharId
const makeWChar = V.validateOrThrow(wCharSchema);


// makeWCharId :: Int -> Int -> WCharId
const makeWCharId = (clientId, clock) => {
  return V.validateOrThrow(wCharIdSchema, {
    clientId, clock
  });
};


// wCharIdBeginning :: WCharId
const wCharIdBeginning = makeWCharId(-1, 0);


// wCharIdEnding :: WCharId
const wCharIdEnding = makeWCharId(-1, 1);


// -- special character to mark the beginning of a wString
// -- note: clientId of -1 denotes a special character generated by this library
// -- includes a self-referential 'prevId' field
// wCharBeginning :: WCharId
const wCharBeginning = makeWChar({
  id: wCharIdBeginning,
  isVisible: false,
  alpha: ' ',
  prevId: wCharIdBeginning,
  nextId: wCharIdEnding
});


// -- special character to mark the ending of a wString
// -- note: clientId of -1 denotes a special character generated by this library
// -- includes a self-referential 'nextId' field
// wCharEnding :: WCharId
const wCharEnding = makeWChar({
  id: wCharIdEnding,
  isVisible: false,
  alpha: ' ',
  prevId: wCharIdBeginning,
  nextId: wCharIdEnding
});


// hide :: WChar -> WChar
const hide = R.assoc('isVisible', false);


// compareCharIds :: WCharId -> WCharId -> Ordering (-1, 0, 1)
const compareWCharIds = R.comparator((idA, idB) => {
  if (idA.clientId === idB.clientId) {
    return idA.clock < idB.clock;
  }

  return idA.clientId < idB.clientId;
});


export default {
  makeWChar,
  makeWCharId,
  wCharBeginning,
  wCharEnding,
  hide,
  compareWCharIds
};
